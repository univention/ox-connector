#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright 2020 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

"""
Entry point for listener_trigger script.
"""

import datetime
import dbm.gnu
import json
import logging
import sys
import time
import traceback
from copy import deepcopy
from pathlib import Path
from urllib.parse import urlparse
from contextlib import contextmanager

from univention.ox.backend_base import get_ox_integration_class
from univention.ox.soap.config import (
    DEFAULT_IMAP_SERVER,
    DEFAULT_LANGUAGE,
    DEFAULT_SMTP_SERVER,
    LOCAL_TIMEZONE,
    NoContextAdminPassword,
)

logger = logging.getLogger("univention.ox")
logger.setLevel(logging.INFO)
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter("%(name)s: %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)
logger = logging.getLogger("listener")
logger.setLevel(logging.INFO)
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter("%(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)


# import http.client as http_client
# http_client.HTTPConnection.debuglevel = 1
# requests_log = logging.getLogger("requests.packages.urllib3")
# requests_log.setLevel(logging.DEBUG)
# requests_log.propagate = True
# handler = logging.StreamHandler(sys.stdout)
# formatter = logging.Formatter("%(name)s: %(message)s")
# handler.setFormatter(formatter)
# requests_log.addHandler(handler)


Context = get_ox_integration_class("SOAP", "Context")
User = get_ox_integration_class("SOAP", "User")
Group = get_ox_integration_class("SOAP", "Group")
Resource = get_ox_integration_class("SOAP", "Resource")

TEST_LOG_FILE = Path("/tmp/test.log")


class Skip(Exception):
    """Raise anywhere if you want to skip the processing of this object"""

    pass


def get_context_id(attributes):
    context_id = attributes.get("oxContext")
    if context_id is None:
        raise Skip("Object has no oxContext attribute!")
    return context_id


# oxmail/oxcontext
# ================
def context_from_attributes(attributes):
    context = Context(id=attributes["contextid"])
    update_context(context, attributes)
    return context


def update_context(context, attributes):
    context.max_quota = attributes.get("oxQuota")
    context.name = attributes["name"]


def context_exists(obj):
    if obj.attributes is None:
        # before delete
        context_id = obj.old_attributes["contextid"]
    else:
        # before create
        context_id = obj.attributes["contextid"]
    return bool(Context.list(pattern=context_id))


def create_context(obj):
    logger.info(f"Creating {obj}")
    if context_exists(obj):
        logger.info(f"{obj} exists. Modifying instead...")
        return modify_context(obj)
    context = context_from_attributes(obj.attributes)
    context.create()


def modify_context(obj):
    logger.info(f"Modifying {obj}")
    if obj.old_attributes:
        context = context_from_attributes(obj.old_attributes)
        update_context(context, obj.attributes)
    else:
        logger.info(f"{obj} has no old data. Resync?")
        context = context_from_attributes(obj.attributes)
    context.modify()


def delete_context(obj):
    logger.info(f"Deleting {obj}")
    if not context_exists(obj):
        logger.info(f"{obj} does not exist. Doing nothing...")
        return
    context = context_from_attributes(obj.old_attributes)
    context.remove()
    obj.attributes = None  # make obj.was_deleted() return True


# oxresources/oxresources
# ================
def resource_from_attributes(attributes, resource_id=None):
    context_id = get_context_id(attributes)
    resource = Resource(id=resource_id, context_id=context_id)
    update_resource(resource, attributes)
    return resource


def update_resource(resource, attributes):
    resource.name = attributes.get("name")
    resource.description = attributes.get("description")
    resource.display_name = attributes.get("displayname")
    resource.email = attributes.get("resourceMailAddress")


def get_resource_id(attributes):
    context_id = get_context_id(attributes)
    name = attributes.get("name")
    resources = Resource.list(context_id, pattern=name)
    if not resources:
        return None
    assert len(resources) == 1
    return resources[0].id


def create_resource(obj):
    logger.info(f"Creating {obj}")
    if get_resource_id(obj.attributes):
        logger.info(f"{obj} exists. Modifying instead...")
        return modify_resource(obj)
    resource = resource_from_attributes(obj.attributes)
    resource.create()


def modify_resource(obj):
    logger.info(f"Modifying {obj}")
    resource_id = get_resource_id(obj.old_attributes)
    if not resource_id:
        logger.info(f"{obj} does not yet exist. Creating instead...")
        return create_resource(obj)
    if obj.old_attributes:
        old_context = get_context_id(obj.old_attributes)
        new_context = get_context_id(obj.attributes)
        if old_context != new_context:
            logging.info(f"Changing context: {old_context} -> {new_context}")
            already_existing_resource_id = get_resource_id(obj.attributes)
            if already_existing_resource_id:
                logger.warning(
                    f"{obj} was found in context {old_context} with ID {resource_id} and in {new_context} with {already_existing_resource_id}. This should not happen. Will delete in {old_context} and modify in {new_context}"  # noqa
                )
                delete_resource(deepcopy(obj))
            else:
                create_resource(obj)
                return delete_resource(deepcopy(obj))
        resource = resource_from_attributes(obj.old_attributes, resource_id)
        update_resource(resource, obj.attributes)
    else:
        logger.info(f"{obj} has no old data. Resync?")
        resource = resource_from_attributes(obj.attributes, resource_id)
    resource.modify()


def delete_resource(obj):
    logger.info(f"Deleting {obj}")
    resource_id = get_resource_id(obj.old_attributes)
    if not resource_id:
        logger.info(f"{obj} does not exist. Doing nothing...")
        return
    resource = resource_from_attributes(obj.old_attributes, resource_id)
    resource.remove()
    obj.attributes = None  # make obj.was_deleted() return True


# users/user
# ==========
def str2isodate(text):  # type: (str) -> str
    exc1 = exc2 = None
    try:
        the_date = datetime.datetime.strptime(text, "%Y-%m-%d")
        return "{:%Y-%m-%d}".format(the_date)
    except (TypeError, ValueError) as exc:
        exc1 = exc
    try:
        the_date = datetime.datetime.strptime(text, "%d.%m.%Y")
        return "{:%Y-%m-%d}".format(the_date)
    except (TypeError, ValueError) as exc:
        exc2 = exc
    raise ValueError(
        "Value {!r} in unknown date format or year before 1900 ({} {}).".format(
            text, exc1, exc2
        )
    )


def user_from_attributes(attributes, user_id=None):
    user = User(id=user_id)
    if attributes:
        context_id = get_context_id(attributes)
        user.context_id = context_id
        update_user(user, attributes)
    return user


def update_user(user, attributes):
    user.context_admin = False
    user.name = attributes.get("username")
    user.display_name = attributes.get("oxDisplayName")
    user.password = "dummy"
    user.given_name = attributes.get("firstname")
    user.sur_name = attributes.get("lastname")
    user.default_sender_address = attributes.get("mailPrimaryAddress")  # TODO: ???
    # user.assistant_name = attributes.get()
    user.branches = attributes.get("oxBranches")
    # user.business_category = attributes.get()
    user.cellular_telephone1 = attributes.get("oxMobileBusiness")
    user.cellular_telephone2 = attributes.get("mobile")
    user.city_business = attributes.get("city")
    user.city_home = attributes.get("oxCityHome")
    user.city_other = attributes.get("oxCityOther")
    user.commercial_register = attributes.get("oxCommercialRegister")
    user.company = attributes.get("organisation")
    user.country_business = attributes.get("oxCountryBusiness")
    user.country_home = attributes.get("oxCountryHome")
    user.country_other = attributes.get("oxCountryOther")
    # user.drive_user_folder_mode = attributes.get()
    # user.default_group = attributes.get()
    user.department = attributes.get("oxDepartment")
    user.email1 = attributes.get("mailPrimaryAddress")
    user.primary_email = user.email1
    user.imap_login = user.email1
    user.email2 = attributes.get("oxEmail2")
    user.email3 = attributes.get("oxEmail3")
    # user.categories = attributes.get('employeeType')  # TODO: or employee_type?
    # user.employee_type = attributes.get('employeeType')  # TODO: or categories?
    user.fax_business = attributes.get("oxFaxBusiness")
    user.fax_home = attributes.get("oxFaxHome")
    user.fax_other = attributes.get("oxFaxOther")
    # user.filestore_id = attributes.get()
    # user.filestore_name = attributes.get()
    # user.folder_tree = attributes.get()
    # user.gui_preferences_for_soap = attributes.get()
    user.gui_spam_filter_enabled = True
    # user.info = attributes.get()
    user.instant_messenger1 = attributes.get("oxInstantMessenger1")
    user.instant_messenger2 = attributes.get("oxInstantMessenger2")
    user.language = attributes.get("oxLanguage", DEFAULT_LANGUAGE)
    # user.mail_folder_confirmed_ham_name = attributes.get()
    # user.mail_folder_confirmed_spam_name = attributes.get()
    # user.mail_folder_drafts_name = attributes.get()
    # user.mail_folder_sent_name = attributes.get()
    # user.mail_folder_spam_name = attributes.get()
    # user.mail_folder_trash_name = attributes.get()
    # user.mail_folder_archive_full_name = attributes.get()
    user.manager_name = attributes.get("oxManagerName")
    user.marital_status = attributes.get("oxMarialStatus")
    user.middle_name = attributes.get("oxMiddleName")
    user.nickname = attributes.get("oxNickName")
    user.note = attributes.get("oxNote")
    user.number_of_children = attributes.get("oxNumOfChildren")
    user.number_of_employee = attributes.get("employeeNumber")
    # user.password_mech = attributes.get()
    # user.password_expired = attributes.get()
    user.position = attributes.get("oxPosition")
    user.postal_code_business = attributes.get("postcode")
    user.postal_code_home = attributes.get("oxPostalCodeHome")
    user.postal_code_other = attributes.get("oxPostalCodeOther")
    user.profession = attributes.get("oxProfession")
    user.sales_volume = attributes.get("oxSalesVolume")
    user.spouse_name = attributes.get("oxSpouseName")
    user.state_business = attributes.get("oxStateBusiness")
    user.state_home = attributes.get("oxStateHome")
    user.state_other = attributes.get("oxStateOther")
    user.street_business = attributes.get("street")
    user.street_home = attributes.get("oxStreetHome")
    user.street_other = attributes.get("oxStreetOther")
    user.suffix = attributes.get("oxSuffix")
    user.tax_id = attributes.get("oxTaxId")
    user.telephone_assistant = attributes.get("oxTelephoneAssistant")
    # user.telephone_callback = attributes.get()
    user.telephone_car = attributes.get("oxTelephoneCar")
    user.telephone_company = attributes.get("oxTelephoneCompany")
    user.telephone_ip = attributes.get("oxTelephoneIp")
    # user.telephone_isdn = attributes.get()
    user.telephone_other = attributes.get("oxTelephoneOther")
    # user.telephone_primary = attributes.get()
    # user.telephone_radio = attributes.get()
    user.telephone_telex = attributes.get("oxTelephoneTelex")
    user.telephone_ttytdd = attributes.get("oxTelephoneTtydd")
    user.timezone = attributes.get("oxTimeZone", LOCAL_TIMEZONE)
    user.title = attributes.get("title")
    # user.upload_file_size_limit = attributes.get()
    # user.upload_file_size_limitPerFile = attributes.get()
    user.url = attributes.get("oxUrl")
    user.used_quota = attributes.get("oxUserQuota")  # TODO: or max_quota?
    user.max_quota = attributes.get("oxUserQuota")  # TODO: or used_quota?
    # user.user_attributes = attributes.get()
    user.userfield01 = attributes.get("oxUserfield01")
    user.userfield02 = attributes.get("oxUserfield02")
    user.userfield03 = attributes.get("oxUserfield03")
    user.userfield04 = attributes.get("oxUserfield04")
    user.userfield05 = attributes.get("oxUserfield05")
    user.userfield06 = attributes.get("oxUserfield06")
    user.userfield07 = attributes.get("oxUserfield07")
    user.userfield08 = attributes.get("oxUserfield08")
    user.userfield09 = attributes.get("oxUserfield09")
    user.userfield10 = attributes.get("oxUserfield10")
    user.userfield11 = attributes.get("oxUserfield11")
    user.userfield12 = attributes.get("oxUserfield12")
    user.userfield13 = attributes.get("oxUserfield13")
    user.userfield14 = attributes.get("oxUserfield14")
    user.userfield15 = attributes.get("oxUserfield15")
    user.userfield16 = attributes.get("oxUserfield16")
    user.userfield17 = attributes.get("oxUserfield17")
    user.userfield18 = attributes.get("oxUserfield18")
    user.userfield19 = attributes.get("oxUserfield19")
    user.userfield20 = attributes.get("oxUserfield20")
    # user.primary_account_name = attributes.get()
    # user.convert_drive_user_folders = attributes.get()
    if attributes.get("roomNumber"):
        user.room_number = attributes.get("roomNumber")[0]
    else:
        user.room_number = None
    if attributes.get("pagerTelephoneNumber"):
        user.telephone_pager = attributes.get("pagerTelephoneNumber")[0]
    else:
        user.telephone_pager = None
    if attributes.get("oxAnniversary"):
        user.anniversary = str2isodate(attributes.get("oxAnniversary"))
    else:
        user.anniversary = None
    if attributes.get("oxBirthday"):
        user.birthday = str2isodate(attributes.get("oxBirthday"))
    else:
        user.birthday = None
    if len(attributes.get("phone", [])) >= 1:
        user.telephone_business1 = attributes.get("phone")[0]
    else:
        user.telephone_business1 = None
    if len(attributes.get("phone", [])) >= 2:
        user.telephone_business2 = attributes.get("phone")[1]
    else:
        user.telephone_business2 = None
    if len(attributes.get("homeTelephoneNumber", [])) >= 1:
        user.telephone_home1 = attributes.get("homeTelephoneNumber")[0]
    else:
        user.telephone_home1 = None
    if len(attributes.get("homeTelephoneNumber", [])) >= 2:
        user.telephone_home2 = attributes.get("homeTelephoneNumber")[1]
    else:
        user.telephone_home2 = None
    aliases = [user.email1] + attributes.get("mailAlternativeAddress", [])
    user.aliases = aliases
    if attributes.get("oxAccess", "none") != "none":
        user.mail_enabled = True
    else:
        user.mail_enabled = False

    imap_url = urlparse(DEFAULT_IMAP_SERVER)
    user.imap_port = imap_url.port  # 143
    user.imap_schema = imap_url.scheme + "://"  # 'imap://'
    user.imap_server = attributes.get("mailHomeServer", imap_url.hostname)
    # user.imap_server_string = attributes.get()
    smtp_url = urlparse(DEFAULT_SMTP_SERVER)
    user.smtp_port = smtp_url.port  # 587
    user.smtp_schema = smtp_url.scheme + "://"  # 'smtp://'
    user.smtp_server = attributes.get("mailHomeServer", smtp_url.hostname)
    # user.smtp_server_string = attributes.get()


def set_user_rights(user, obj):
    access_rights = dict(
        (access, False)
        for access in [
            "OLOX20",
            "USM",
            "activeSync",
            "calendar",
            "collectEmailAddresses",
            "contacts",
            "delegateTask",
            "deniedPortal",
            "editGroup",
            "editPassword",
            "editPublicFolders",
            "editResource",
            "globalAddressBookDisabled",
            "ical",
            "infostore",
            "multipleMailAccounts",
            "publicFolderEditable",
            "publication",
            "readCreateSharedFolders",
            "subscription",
            "syncml",
            "tasks",
            "vcard",
            "webdav",
            "webdavXml",
            "webmail",
        ]
    )

    attributes = obj.attributes
    if attributes.get("oxAccess", "none") != "none":
        if attributes.get("oxAccess") == "webmail":
            access = "contacts webmail collectEmailAddresses multipleMailAccounts subscription publication"  # noqa
        if attributes.get("oxAccess") == "pim":
            access = "calendar contacts delegateTask tasks webmail collectEmailAddresses multipleMailAccounts subscription publication"  # noqa
        if attributes.get("oxAccess") == "groupware":
            access = "calendar contacts delegateTask editPublicFolders infostore readCreateSharedFolders tasks webmail collectEmailAddresses multipleMailAccounts subscription publication"  # noqa
        if attributes.get("oxAccess") == "premium":
            access = "calendar contacts delegateTask editPublicFolders ical infostore readCreateSharedFolders tasks vcard webdav webdavXml webmail collectEmailAddresses multipleMailAccounts subscription publication USM OLOX20"  # noqa
        if attributes.get("oxAccessUSM", "Not") == "OK":
            access += " USM activeSync"
        if attributes.get("oxDrive", "1") == "1":
            access += " infostore"
        for acc in access.split():
            access_rights[acc] = True
    access_rights["syncml"] = bool(attributes.get("oxAccessSyncMl"))
    access_rights["editResource"] = bool(attributes.get("oxAccessResources"))
    user.service(user.context_id).change_by_module_access(
        {"id": user.id}, access_rights
    )


def get_user_id(attributes):
    context_id = get_context_id(attributes)
    username = attributes.get("username")
    logger.info(f"Searching for {username} in context {context_id}")
    users = User.list(context_id, pattern=username)
    if not users:
        return None
    assert len(users) == 1
    return users[0].id


def create_user(obj):
    logger.info(f"Creating {obj}")
    if obj.attributes.get("isOxUser", "Not") == "Not":
        logger.info(f"{obj} is no OX user. Deleting instead...")
        return delete_user(obj)
    if get_user_id(obj.attributes):
        logger.info(f"{obj} exists. Modifying instead...")
        return modify_user(obj)
    user = user_from_attributes(obj.attributes)
    user.create()
    set_user_rights(user, obj)


def modify_user(obj):
    logger.info(f"Modifying {obj}")
    if obj.attributes.get("isOxUser", "Not") == "Not":
        logger.info(f"{obj} is no OX user. Deleting instead...")
        return delete_user(obj)
    user_id = get_user_id(obj.old_attributes)
    if not user_id:
        logger.info(f"{obj} does not yet exist. Creating instead...")
        return create_user(obj)
    if obj.old_attributes:
        if obj.old_attributes.get("isOxUser", "Not") == "Not":
            logger.warning(
                f"{obj} was no OX user before... that should not be the case. Modifying anyway..."
            )
        old_context = get_context_id(obj.old_attributes)
        new_context = get_context_id(obj.attributes)
        if old_context != new_context:
            logging.info(f"Changing context: {old_context} -> {new_context}")
            already_existing_user_id = get_user_id(obj.attributes)
            if already_existing_user_id:
                logger.warning(
                    f"{obj} was found in context {old_context} with ID {user_id} and in {new_context} with {already_existing_user_id}. This should not happen. Will delete in {old_context} and modify in {new_context}"  # noqa
                )
                delete_user(deepcopy(obj))
            else:
                create_user(obj)
                return delete_user(deepcopy(obj))
        user = user_from_attributes(obj.old_attributes, user_id)
        update_user(user, obj.attributes)
    else:
        logger.info(f"{obj} has no old data. Resync?")
        user = user_from_attributes(obj.attributes, user_id)
    user.modify()
    set_user_rights(user, obj)


def delete_user(obj):
    logger.info(f"Deleting {obj}")
    if obj.old_attributes is None:
        logger.info("No attributes to work with. Doing nothing...")
        return
    user_id = get_user_id(obj.old_attributes)
    if not user_id:
        logger.info(f"{obj} does not exist. Doing nothing...")
        return
    user = user_from_attributes(obj.old_attributes, user_id)
    group_service = Group.service(user.context_id)
    soap_groups = group_service.list_groups_for_user({"id": user.id})
    user.remove()
    obj.attributes = None  # make obj.was_deleted() return True
    logger.info("User was deleted, searching for now empty groups")
    for soap_group in soap_groups:
        logger.info(
            f"Found group {soap_group.name} with {len(soap_group.members)} members"
        )
        if len(soap_group.members) <= 1:
            logger.info(f"Thus, deleting group {soap_group.id} in {user.context_id}...")
            group_service.delete(soap_group)


# groups/group
# ==========
def get_group_objs(obj):  # noqa: C901
    users = []
    ignored_group = True
    if obj.old_attributes:
        users.extend(obj.old_attributes.get("users"))
        if obj.old_attributes.get("isOxGroup", "Not") != "Not":
            logger.info(f"Group {obj.old_attributes['name']} was OX Group")
            ignored_group = False
    if obj.attributes:
        users.extend(obj.attributes.get("users"))
        if obj.attributes.get("isOxGroup", "Not") != "Not":
            logger.info(f"Group {obj.attributes['name']} will be OX Group")
            ignored_group = False
    if ignored_group:
        return
    contexts = []
    for user in users:
        path_to_old_user = mapping.get(user)
        if not path_to_old_user:
            logger.info(
                f"Group wants {user} as member. But the user is unknown. Ignoring..."
            )
            continue
        path_to_old_user = Path(path_to_old_user.decode("utf-8"))
        user_obj = object_from_path(path_to_old_user)
        try:
            context = get_context_id(user_obj.attributes)
        except Skip:
            continue
        if context not in contexts:
            contexts.append(context)
    for context in contexts:
        new_obj = deepcopy(obj)
        if new_obj.old_attributes:
            new_obj.old_attributes["oxContext"] = context
        if new_obj.attributes:
            new_obj.attributes["oxContext"] = context
        logger.info(f"{obj} will be processed with context {context}")
        yield new_obj


def group_from_attributes(attributes, group_id=None):
    group = Group(id=group_id)
    if attributes:
        context_id = attributes["oxContext"]
        group.context_id = context_id
        update_group(group, attributes)
    return group


def update_group(group, attributes):
    group.name = attributes.get("name")
    group.display_name = group.name
    if attributes.get("isOxGroup", "Not") == "Not":
        # no need to search anything...
        # specifically skip "Domain Users"... this would be expensive
        return
    members = []
    logger.info("Retrieving members...")
    for user in attributes.get("users"):
        username = user[4:].split(",")[0]  # TODO: make this more elegant
        user_attributes = {}
        user_attributes["oxContext"] = get_context_id(attributes)
        user_attributes["username"] = username
        user_id = get_user_id(user_attributes)
        if user_id:
            logger.info(f"... found {user_id}")
            members.append(user_id)
    group.members = members


def get_group_id(obj):
    if obj.old_attributes is not None:
        # before delete
        context_id = obj.old_attributes["oxContext"]
        groupname = obj.old_attributes.get("name")
    else:
        # before create
        context_id = obj.attributes["oxContext"]
        groupname = obj.attributes.get("name")
    # ignore groups with name "users" (Bug #35821)
    if groupname.lower() == "users":
        logger.info(f'Ignoring group "{groupname}"')
        return None
    groups = Group.list(context_id, pattern=groupname)
    if not groups:
        return None
    assert len(groups) == 1
    return groups[0].id


def create_group(obj):
    logger.info(f"Creating {obj}")
    if obj.attributes.get("isOxGroup", "Not") == "Not":
        logger.info(f"{obj} is no OX group. Deleting instead...")
        return delete_group(obj)
    if get_group_id(obj):
        logger.info(f"{obj} exists. Modifying instead...")
        return modify_group(obj)
    group = group_from_attributes(obj.attributes)
    if not group.members:
        logger.info(f"{obj} is empty. Deleting instead...")
        return delete_group(obj)
    # ignore groups with name "users" (Bug #35821)
    if group.name == "users":
        return
    group.create()


def modify_group(obj):
    logger.info(f"Modifying {obj}")
    if obj.attributes.get("isOxGroup", "Not") == "Not":
        logger.info(f"{obj} is no OX group. Deleting instead...")
        return delete_group(obj)
    group_id = get_group_id(obj)
    if not group_id:
        logger.info(f"{obj} does not yet exist. Creating instead...")
        return create_group(obj)
    if obj.old_attributes:
        if obj.old_attributes.get("isOxGroup", "Not") == "Not":
            logger.info(
                f"{obj} was no OX group before... that should not be the case. Modifying anyway..."
            )
        group = group_from_attributes(obj.old_attributes, group_id)
        update_group(group, obj.attributes)
    else:
        logger.info(f"{obj} has no old data. Resync?")
        group = group_from_attributes(obj.attributes, group_id)
    if not group.members:
        logger.info(f"{obj} is empty. Deleting instead...")
        return delete_group(obj)
    group.modify()


def delete_group(obj):
    logger.info(f"Deleting {obj}")
    group_id = get_group_id(obj)
    if not group_id:
        logger.info(f"{obj} does not exist. Doing nothing...")
        return
    group = group_from_attributes(obj.old_attributes, group_id)
    group.remove()
    obj.attributes = None  # make obj.was_deleted() return True


# ## ## ## ## ## ## ## ## #
# end ox listener lib #####
# begin listener skeleton #


APP = "ox-connector"
DATA_DIR = Path("/var/lib/univention-appcenter/apps", APP, "data")
NEW_FILES_DIR = DATA_DIR / "listener"
OLD_FILES_DIR = NEW_FILES_DIR / "old"


def load_from_json_file(path):
    """
    Just a helper function to get JSON content from a file, if it
    exists
    """
    if not path.exists():
        return None
    with path.open() as fd:
        return json.load(fd)


class TriggerObject(object):
    """
    A thin wrapper over a JSON file. Holds all the information from that
    file. May also hold information of this object from a previous run
    (needs a second, backup file for that)
    """

    def __init__(self, entry_uuid, object_type, dn, attributes, options, path=None):
        self.entry_uuid = entry_uuid
        self.object_type = object_type
        self.dn = dn
        self.attributes = attributes
        self.options = options
        self.old_dn = None
        self.old_attributes = None
        self.old_options = None
        self.path = path  # file where it originates from
        self._old_loaded = False

    def ordering(self, other):
        """Sort incoming objects if needed. Return True whenever self should be
        placed BEFORE other. So return False would be the default."""
        sorted_object_types = [
            "oxmail/oxcontext",
            "users/user",
            "groups/group",
            "oxresources/oxresources",
        ]
        if self.object_type == "oxmail/oxcontext" and self.attributes is None:
            # deleting a context should always come last
            return False
        if other.object_type == "oxmail/oxcontext" and other.attributes is None:
            # deleting a context should always come last
            return True
        lidx = sorted_object_types.index(self.object_type)
        ridx = sorted_object_types.index(other.object_type)
        return lidx < ridx

    def get_old_file_path(self):
        """
        Name of the old file. May or may not be present. Is used by
        objects_from_files to move files if speceified.
        """
        return OLD_FILES_DIR / "{}.json".format(self.entry_uuid)

    def load_old(self):
        """Loads the old filename and sets attributes accordingly"""
        old_path = self.get_old_file_path()
        content = load_from_json_file(old_path)
        if content is not None:
            self.old_dn = content["dn"]
            self.old_attributes = content["object"]
            self.old_options = content["options"]
        self._old_loaded = True

    def was_added(self):
        """
        Whether this object is new. Needs the have read an old file
        for this to give a meaningful response
        """
        if self._old_loaded is False:
            return None
        return self.old_dn is None

    def was_modified(self):
        """
        Whether this object was modified. Needs the have read an old
        file for this to give a meaningful response
        """
        if self.was_deleted():
            return False
        if self._old_loaded is False:
            return None
        return not self.was_added() and not self.was_deleted()

    def was_deleted(self):
        """Whether this object was deleted."""
        return self.attributes is None

    def __repr__(self):
        return "Object({!r}, {!r})".format(self.object_type, self.dn)


class KeyValueStore(object):
    """
    Database about meta information on this listener.
    Particularly the number of consecutive errors.
    """

    def __init__(self, name):
        self.db_fname = str(NEW_FILES_DIR / name)

    @contextmanager
    def open(self):
        with dbm.gnu.open(self.db_fname, "cs") as db:
            yield db

    def set(self, dn, path):
        if dn is None:
            return
        with self.open() as db:
            if path is None:
                if dn in db:
                    del db[dn]
            else:
                db[dn] = str(path)

    def get(self, key):
        with self.open() as db:
            return db.get(key)


meta = KeyValueStore("meta.db")  # arbitrary data, at the moment only stores consecutive errors
mapping = KeyValueStore("old.db")  # stores dn -> path to last json file


def object_from_path(path):
    """Extract object information from JSON file"""
    content = load_from_json_file(path)
    entry_uuid = content["id"]
    object_type = content["udm_object_type"]
    dn = content["dn"]
    attributes = content["object"]
    options = content["options"]
    obj = TriggerObject(entry_uuid, object_type, dn, attributes, options, path)
    return obj


def objects_from_files(delete_files=True, move_files=False):
    """
    Iterates over all JSON files and yields a TriggerObject. After the
    caller is done with it, it can delete or move the file. If it moves the
    file, a copy of this very JSON file is created so that a new run can
    reload it (useful if you need to act on various changes in
    attributes)
    """
    objs = []
    for path in sorted(NEW_FILES_DIR.glob("*.json")):
        obj = object_from_path(path)
        if move_files:
            obj.load_old()
        if obj.attributes is None and obj.old_attributes is None:
            # happens when creation and deletion happens within one
            # "listener cycle" => nothing happened
            path.unlink()
        else:
            idx = 0
            for _obj, _ in objs:
                if obj.ordering(_obj):
                    break
                idx += 1
            objs.insert(idx, (obj, path))

    for obj, path in objs:
        yield obj
        if move_files:
            mapping.set(obj.old_dn, None)
            if obj.was_deleted():
                logger.info(f"Object was deleted. Deleting {path}")
                path.unlink()
                mapping.set(obj.dn, None)
            else:
                old_file_path = obj.get_old_file_path()
                logger.info(f"mv {path} -> {old_file_path}")
                old_file_path.parent.mkdir(parents=True, exist_ok=True)
                if old_file_path.exists():
                    old_file_path.unlink()
                path.replace(old_file_path)
                mapping.set(obj.dn, old_file_path)
        elif delete_files:
            logger.info(f"Deleting {path}")
            path.unlink()


def run_on_files(
    objs,
    f,
    stop_at_first_error=True,
    pause_after_errors_num=0,
    pause_after_errors_length=0,
):
    """
    Iterate over objects (returned by objects_from_files) and runs a
    function f on this object. May continue to do so even if one iteration
    failed. Returns a reasonable exit code
    """
    ret = 0
    for obj in objs:
        try:
            f(obj)
        except Exception:
            logger.warning(f"Error while processing {obj.path}")
            traceback.print_exc()
            ret = 1
            errors = meta.get("errors")
            if errors is None:
                errors = 1
            else:
                errors = int(errors) + 1
            meta.set("errors", str(errors))
            if stop_at_first_error:
                if 0 < pause_after_errors_num <= errors:
                    logger.warning(f"This is consecutive error #{errors}")
                    logger.warning(f"Sleeping for {pause_after_errors_length} sec")
                    time.sleep(pause_after_errors_length)
                break
        else:
            meta.set("errors", "0")
    return ret


def run(obj):  # noqa: C901
    """This is your main function. Implement all your logic here"""
    if obj.object_type == "oxmail/oxcontext":
        if obj.was_added():
            create_context(obj)
        elif obj.was_modified():
            modify_context(obj)
        elif obj.was_deleted():
            delete_context(obj)
    try:
        if obj.object_type == "users/user":
            if obj.was_added():
                create_user(obj)
            elif obj.was_modified():
                modify_user(obj)
            elif obj.was_deleted():
                delete_user(obj)
        if obj.object_type == "groups/group":
            for new_obj in get_group_objs(obj):
                if new_obj.was_added():
                    create_group(new_obj)
                elif new_obj.was_modified():
                    modify_group(new_obj)
                elif new_obj.was_deleted():
                    delete_group(new_obj)
        if obj.object_type == "oxresources/oxresources":
            if obj.was_added():
                create_resource(obj)
            elif obj.was_modified():
                modify_resource(obj)
            elif obj.was_deleted():
                delete_resource(obj)
    except Skip as exc:
        logger.warning(f"Skipping: {exc}")
    except NoContextAdminPassword as exc:
        logger.warning(
            f"Could not find admin password for context {exc.args[0]}. Ignoring this task"
        )

    # logging for tests
    if TEST_LOG_FILE.exists():
        with TEST_LOG_FILE.open("a") as fp:
            fp.write(f"{obj.dn}\n")


objs = objects_from_files(delete_files=False, move_files=True)
sys.exit(
    run_on_files(objs, run, pause_after_errors_num=3, pause_after_errors_length=60)
)
